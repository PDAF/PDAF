!> Initialize ensemble
!!
!! User-supplied call-back routine for PDAF.
!!
!! Used in all ensemble filters.
!!
!! The routine is called when the filter is
!! initialized in PDAF_filter_init.  It has
!! to initialize an ensemble of dim_ens states.
!!
!! This template shows how the ensemble of dim_ens 
!! states can be initializated by exact 2nd order 
!! sampling using the routien PDAF_SampleEns.
!!
!! More information on this initialization variant can be
!! found on the PDAF web site on ensemble initialization.
!!
!! The routine is called by all filter processes and 
!! initializes the ensemble for the local domain.
!!
!! __Revision history:__
!! * 2004-10 - Lars Nerger - Initial code
!! *Later revisions - see repository log
!!
SUBROUTINE init_ens_pdaf(filtertype, dim_p, dim_ens, state_p, Uinv, &
     ens_p, flag)

  IMPLICIT NONE

! *** Arguments ***
  INTEGER, INTENT(in) :: filtertype              !< Type of filter to initialize
  INTEGER, INTENT(in) :: dim_p                   !< PE-local state dimension
  INTEGER, INTENT(in) :: dim_ens                 !< Size of ensemble
  REAL, INTENT(out)   :: state_p(dim_p)          !< PE-local model state
  REAL, INTENT(out)   :: Uinv(dim_ens-1,dim_ens-1) !< Array not referenced for SEIK
  REAL, INTENT(out)   :: ens_p(dim_p, dim_ens)   !< PE-local state ensemble
  INTEGER, INTENT(inout) :: flag                 !< PDAF status flag


! *** local variables ***
  INTEGER :: i, row, col              ! counters
  INTEGER, SAVE :: allocflag = 0      ! Flag for memory counting
  REAL, ALLOCATABLE :: ens(:,:)       ! global ensemble
  REAL, ALLOCATABLE :: state(:)       ! global state vector
  REAL, ALLOCATABLE :: eofV(:,:)      ! matrix of eigenvectors V 
  REAL, ALLOCATABLE :: svals(:)       ! singular values
  INTEGER :: rank                     ! Rank of approximated covariance matrix
  REAL :: fac                         ! Square-root of dim_ens-1 or dim_ens
  ! variables and arrays for domain decomposition
  INTEGER :: offset                   ! Row-offset according to domain decomposition
  INTEGER :: domain                   ! domain counter
  REAL,ALLOCATABLE :: ens_p_tmp(:,:)  ! Temporary ensemble for some PE-domain
  REAL,ALLOCATABLE :: state_p_tmp(:)  ! Temporary state vector for some PE-domain


! **********************
! *** INITIALIZATION ***
! **********************

  WRITE (*, *) 'TEMPLATE init_ens_pdaf.F90: generate ensemble of model states'

  ! *** Rank of matrix is ensemble size minus one
!   rank = dim_ens - 1
  
  ! *** Generate full ensemble on filter-PE 0 ***
!  mype0: IF (mype_filter == 0) THEN
!      WRITE (*, '(/9x, a)') 'Generate state ensemble from covariance matrix'
!      WRITE (*, '(9x, a)') &
!           '--- use rank reduction and 2nd order exact sampling (SEIK type)'
!      WRITE (*, '(9x, a, i5)') '--- Ensemble size:  ', dim_ens
!      WRITE (*, '(9x, a, i5)') '--- number of EOFs: ', rank


! *************************************************
! *** Initialize initial state and covar matrix ***
! *************************************************

  ! + For recommendations on how an ensemble can be generated see the PDAF
  ! + documentation at https://pdaf.awi.de/trac/wiki/EnsembleGeneration

  ! + We show an example here, in which the ensemble is generated by 
  ! + second-order exact sampling. This method takes a state estimate
  ! + together with an error estimate based on singular values and vectors
  ! + of a covariance matrix P representing the uncertainty. Thus we use
  ! +       P = eofV U eofV^T
  ! + where eofV is the matrix holding the singular vectors and U is a
  ! + diagonal matrix holding the eigenvectors of P. In terms of singular
  ! + values S we use that U = S S^T, where S is the diagonal matrix holding
  ! + singular values. The singular values S and vectors eofV can be
  ! + generated using the routine PDAF_eofcovar.


     ! Allocate memory for temporary fields
!     ALLOCATE(eofV(dim_state, rank))
!     ALLOCATE(svals(rank))
   
     ! Allocate global ensemble and state
!     ALLOCATE(ens(dim_state, dim_ens))
!     ALLOCATE(state(dim_state))

     ! Initialize state vector, vector of singular values, and matrix of singular vectors
!     state(:) = ??
!     svals(1:rank) = ??
!     eofV(:,:) = ??


! **************************************************************************
! *** Generate ensemble using second-order sampling of covariance matrix ***
! **************************************************************************

     ! + Very simple method here: We generate the full 
     ! + ensemble on the filter PE with rank 0. Afterwards
     ! + we distribute sub-states to other filter PEs

     ! Generate ensemble using PDAF sampling routine
!     CALL PDAF_SampleEns(dim_state, dim_ens, eofV, svals, state, &
!           ens, flag)

!  ENDIF mype0


! ****************************
! *** Distribute substates ***
! ****************************

  ! This is an example how one could distribute ensemble information over multiple processes

!   mype0b: IF (mype_filter == 0) THEN
     ! *** Initialize and send sub-state on PE 0 ***

!      ! Initialize sub-ensemble for PE 0
!      DO col = 1, dim_ens
!         DO i=1, dim_p
!            ens_p(i, col) = ens(i, col)
!         END DO
!      END DO
! 
!      ! Define offset in state vectors
!      offset = local_dims(1)
! 
!      DO domain = 2, npes_filter
!         ! Initialize sub-ensemble for other PEs and send sub-arrays
! 
!         ! Allocate temporary buffer array
!         ALLOCATE(ens_p_tmp(local_dims(domain), dim_ens))
! 
!         ! Initialize MPI buffer for local ensemble
!         DO col = 1, dim_ens
!            DO i = 1, local_dims(domain)
!               ens_p_tmp(i, col) = ens(i + offset, col)
!            END DO
!         END DO
! 
!         ! Send sub-arrays
!         CALL MPI_send(ens_p_tmp, dim_ens * local_dims(domain), &
!              MPI_DOUBLE_PRECISION, domain - 1, 1, COMM_filter, MPIerr)
! 
!         DEALLOCATE(ens_p_tmp)
! 
!         ! Increment offset
!         offset = offset + local_dims(domain)
! 
!      END DO
! 
!   ELSE mype0b
!      ! *** Receive ensemble substates on filter-PEs with rank > 0 ***
! 
!      CALL MPI_recv(ens_p, dim_p * dim_ens, MPI_DOUBLE_PRECISION, &
!           0, 1, COMM_filter, MPIstatus, MPIerr)
!      
!   END IF mype0b


! ****************
! *** clean up ***
! ****************

!   IF (mype_filter == 0) THEN
!      DEALLOCATE(svals, eofV)
!      DEALLOCATE(ens, state)
!   END IF

END SUBROUTINE init_ens_pdaf
