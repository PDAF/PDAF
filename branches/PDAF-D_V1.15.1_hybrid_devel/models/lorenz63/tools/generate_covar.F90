! $Id: generate_covar.F90 79 2019-02-09 15:29:27Z lnerger $
!BOP
!
! !Program: generate_covar --- Compute covariance matrix from state trajectory
!
! !INTERFACE:
PROGRAM generate_covar

! !DESCRIPTION:
! This programm to computes a covariance matrix from a
! model trajectory of Lorenz63. The matrix is decomposed in
! EOFs and stored in form of eigenvalues and eigenvectors.
!
! The matrix is generated by a singular value decomposition
! of the perturbation matrix of a long state trajectory
! about its long time mean.

! !USES:
  IMPLICIT NONE

  INCLUDE 'netcdf.inc'
!EOP
  
! Local variables
  INTEGER :: i, k, s, iter, rank                ! Counters
  INTEGER :: delta_step, step_start, ntimes     ! Counters
  CHARACTER(len=120) :: inpath, outpath         ! File paths
  CHARACTER(len=120) :: infile, outfile         ! File names
  CHARACTER(len=150) :: ncfile_in, ncfile_out   ! File name including path
  CHARACTER(len=150) :: attstr                  ! Attribute string for NC (NetCDF) output
  INTEGER :: ncid_in, ncid_out                  ! NC file IDs
  INTEGER :: id_dim, id_time, id_state          ! NC dimension and variable IDs
  INTEGER :: id_mean, id_sigma, id_svec         ! NC dimension and variable IDs
  INTEGER :: dimid_rank, dimid_state, dimid_one ! NC dimension and variable IDs
  INTEGER :: steps, dim_state                   ! Dimensions
  INTEGER :: stat(100)                          ! Status for NC operations
  INTEGER :: countv(2), startv(2)               ! Vectors for NC operations
  INTEGER :: dimids(2)                          ! Vector for NC operations
  REAL :: limit                                 ! Lower limit for singular values
  REAL, ALLOCATABLE :: times(:)                 ! Array of times from NC file
  REAL, ALLOCATABLE :: states(:, :)             ! State trajectory
  REAL, ALLOCATABLE :: meanstate(:)             ! Mean state of trajectory
  INTEGER :: status                             ! Status Flag
  REAL,ALLOCATABLE,DIMENSION(:) :: svals        ! field of singular values
  REAL,ALLOCATABLE,DIMENSION(:,:) :: svdU       ! left singular vectors

  ! Controls for PDAF_eofcovar
  INTEGER :: remove_mean  ! (1) Let PDAF_eofcovar compute and subtract the mean state;
                          ! (0) mean already removed from trajectory
  INTEGER :: do_mv        ! (1) to perform multivariate normalization; (0) no normalization

  ! Unused, but required variables for PDAF_eofcovar
  INTEGER :: nfields        ! Number of fields
  INTEGER :: dim_fields(1)  ! Size of field (only for multivariate scaling (not used here))
  INTEGER :: offsets(1)     ! Offset of fields (only for multivariate scaling (not used here))
  REAL :: stddev(1)         ! STDDEV of field (only for multivariate scaling (not used here))


! ************************************************
! *** Configuration                            ***
! ************************************************

  ! Time step interval to read
  delta_step = 10

  ! Initial time step to read from
  step_start = 100

  ! Number of steps to read
  ntimes = 400

  ! Path to and name of file holding model trajectory
  inpath = '../'
  infile = 'state_l63.nc'

  ! Path to and name of output file holding covariance matrix
  outpath = '../'
  outfile = 'covar_l63.nc'

  ! Lower limit for eigenvalue
  limit = 1.0e-12


! ************************************************
! *** Init                                     ***
! ************************************************

  WRITE (*,'(10x,a)') '*******************************************'
  WRITE (*,'(10x,a)') '*             GENERATE_COVAR              *'
  WRITE (*,'(10x,a)') '*                                         *'
  WRITE (*,'(10x,a)') '*    Compute covariance matrix and mean   *'
  WRITE (*,'(10x,a)') '*     state from a sequence of states.    *'
  WRITE (*,'(10x,a)') '*                                         *'
  WRITE (*,'(10x,a)') '*   Write covar matrix as scaled eigen-   *'
  WRITE (*,'(10x,a)') '*    vectors and singular values into     *'
  WRITE (*,'(10x,a)') '*              NetCDF file                *'
  WRITE (*,'(10x,a/)') '*******************************************'

  ncfile_in = TRIM(inpath)//TRIM(infile)
  WRITE (*,*) 'Read trajectory from file: ',TRIM(ncfile_in)

  ncfile_out = TRIM(outpath)//TRIM(outfile)
  WRITE (*,*) 'Write covariance matrix to file: ',TRIM(ncfile_out)


! ************************************************
! *** Open trajectory file and read dimensions ***
! ************************************************

  s = 1
  stat(s) = NF_OPEN(TRIM(ncfile_in), NF_NOWRITE, ncid_in)
  s = s + 1

  ! Get dimensions
  stat(s) = NF_INQ_DIMID(ncid_in, 'dim_state', id_dim)
  s = s + 1
  stat(s) = NF_INQ_DIMLEN(ncid_in, id_dim, dim_state)
  s = s + 1
  stat(s) = NF_INQ_DIMID(ncid_in, 'timesteps', id_dim)
  s = s + 1
  stat(s) = NF_INQ_DIMLEN(ncid_in, id_dim, steps)

  ! Initialize time array
  ALLOCATE(times(steps))
  s = s + 1
  stat(s) = NF_INQ_VARID(ncid_in, 'time', id_time)
  s = s + 1
  stat(s) = NF_GET_VAR_DOUBLE(ncid_in, id_time, times)

  ! Get state variable ID
  s = s + 1
  stat(s) = NF_INQ_VARID(ncid_in, 'state', id_state)

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in reading dimensions, no.', i
  END DO

  WRITE (*,'(/1x,a)') 'Dimensions of experiment:'
  WRITE (*,'(8x,a,i10)') 'state dimension', dim_state
  WRITE (*,'(5x,a,i10)')    'time steps in file', steps
  WRITE (*,'(9x,a,i10,a,i10)')   'read from step', step_start,' with interval', delta_step

  IF (steps < step_start+(ntimes-1)*delta_step ) THEN
     WRITE (*,'(1x,a)') '!! Number of available time slices is smaller than ntimes - resetting!'
     ntimes = (steps - step_start)/delta_step + 1
  END IF
  WRITE (*,'(5x,a,i10)') 'number of times to read', ntimes


! ****************************
! *** Read trajectory data ***
! ****************************

  WRITE (*,'(/1x,a)') '------- Read trajectory -------------'

  ALLOCATE(states(dim_state, ntimes))
  ALLOCATE(meanstate(dim_state))

  read_in: DO iter = step_start, step_start+(ntimes-1)*delta_step, delta_step

     startv(2) = iter
     countv(2) = 1
     startv(1) = 1
     countv(1) = dim_state
     stat(1) = NF_GET_VARA_DOUBLE(ncid_in, id_state, startv, countv, &
          states(1 : dim_state, iter))
     IF (stat(1) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in reading state'

  END DO read_in

  ! Close trajectory file
  stat(1) = nf_close(ncid_in)
  IF (stat(1) /= NF_NOERR) &
       WRITE(*, *) 'NetCDF error in closing trajectory file'


! *********************************************************
! *** Singular value decomposition of covariance matrix ***
! ***                                                   ***
! *** The covariance matrix is given by the state       ***
! *** sequences X of k states as                        ***
! ***          -1    _     _ T        T                 ***
! *** P = (k-1)   (X-X) (X-X)  = U L U  (EVP)           ***
! ***                                                   ***
! *** Thus we compute the singular value decomposition  ***
! ***     _        T            -1    2  T              ***
! ***   X-X = U S V ;  P = (k-1)   U S  U               ***
! ***                                                   ***
! ***                         -1/2                      ***
! *** and we store U and (k-1)     S in a NetCDF file.  ***
! *********************************************************

  WRITE (*,'(/1x,a)') '------- Compute covariance matrix decomposition -------------'

  ! PDAF_eofcovar should compute and subtract the mean state from Trajectory 
  ! before decomposition. Afterwards, it's added again.
  remove_mean = 1

  ! Set some variables only used for multivariate normalization - not here!
  nfields = 1      ! One field
  dim_fields = 40  ! Size of field
  offsets = 0      ! offset of field from beginning of vector
  do_mv = 0   ! For testing one cat set do_mv=1 to activate normalization
  ! Note: multivariate normalization can be useful if there are several fields
  !       with difference variances. Here, we only have one field

  ! Allocate arrays for singular values and vectors
  ALLOCATE(svals(ntimes))
  ALLOCATE(svdU(dim_state, ntimes))

  ! Call routine generating matrix decomposition
  CALL PDAF_eofcovar(dim_state, ntimes, nfields, dim_fields, offsets, &
       remove_mean, do_mv, states, stddev, svals, svdU, meanstate, 1, status)


! *********************************************************
! *** Write mean state and decomposed covariance matrix ***
! *********************************************************

! *** Determine rank to write ***

  getlimit: DO i = 1, ntimes
     IF (svals(i) >= limit) THEN
        rank = i
     ELSE
        EXIT getlimit
     END IF
  END DO getlimit
  IF (rank < ntimes) THEN
     WRITE (*,'(1x,a,i6,a,es10.2)') &
          'Use maximum of ', rank, ' eigenvectors due to eigenvalue-limit of ',limit
  END IF
  IF (rank == ntimes) THEN
     rank = ntimes - 1
     WRITE (*,'(5x,a,i4)') '++ reset rank to ',rank
  END IF

  WRITE (*,'(5x,a)') 'Singular values: '
  DO i = 1, rank
    WRITE (*, '(10x, i4, es12.3)') i, svals(i)
  END DO


  WRITE (*,'(/1x,a)') '------- Write decomposed covariance matrix and mean state -------------'

  ! *** Initialize file
  s = 1
  stat(s) = NF_CREATE(ncfile_out, 0, ncid_out) 

  attstr = 'Mean state, singular vectors and values of decomposed covariance matrix for Lorenz63'
  s = s + 1
  stat(s) = NF_PUT_ATT_TEXT(ncid_out, NF_GLOBAL, 'title', LEN_TRIM(attstr), &
       TRIM(attstr)) 

  ! Define dimensions
  s = s + 1
  stat(s) = NF_DEF_DIM(ncid_out, 'rank',  rank, dimid_rank)
  s = s + 1
  stat(s) = NF_DEF_DIM(ncid_out, 'dim_state', dim_state, dimid_state)
  s = s + 1
  stat(s) = NF_DEF_DIM(ncid_out, 'one',  1, dimid_one)

  ! Define variables
  s = s + 1
  stat(s) = NF_DEF_VAR(ncid_out, 'sigma', NF_DOUBLE, 1, dimid_rank, Id_sigma)

  ! mean state
  dimids(1) = DimId_state
  dimids(2) = dimid_one

  s = s + 1
  stat(s) = NF_DEF_VAR(ncid_out, 'meanstate', NF_DOUBLE, 2, dimids, Id_mean)

  ! singular vectors
  dimids(1) = DimId_state
  dimids(2) = dimid_rank

  s = s + 1
  stat(s) = NF_DEF_VAR(ncid_out, 'u_svd', NF_DOUBLE, 2, dimids, Id_svec)

  ! End Define mode
  s = s + 1
  stat(s) = NF_ENDDEF(ncid_out) 

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in init of output file, no.', i
  END DO

  ! Write singular values
  s = s + 1
  stat(s) = NF_PUT_VAR_DOUBLE(ncid_out, id_sigma, svals(1:rank))


  ! Write mean state
  startv(2) = 1
  countv(2) = 1
  startv(1) = 1
  countv(1) = dim_state
  s = s + 1
  stat(s) = NF_PUT_VARA_DOUBLE(ncid_out, id_mean, startv, countv, meanstate)

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in writing state to output file, no.', i
  END DO


  ! *** Write singular vectors

  writevectors: DO i = 1, rank

    ! Write singular vector
     startv(2) = i
     countv(2) = 1
     startv(1) = 1
     countv(1) = dim_state
     s = 1
     stat(s) = NF_PUT_VARA_DOUBLE(ncid_out, id_svec, startv, countv, svdU(:,i))

     DO k = 1,  s
        IF (stat(k) /= NF_NOERR) &
             WRITE(*, *) 'NetCDF error in writing singular vectors, no.', i,' rank',i
     END DO

  END DO writevectors

  ! Close file
  s = 1
  stat(s) = NF_CLOSE(ncid_out)

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in singular vectors to output file, no.', i
  END DO



! ********************
! *** Finishing up ***
! ********************

  DEALLOCATE(states, meanstate)
  DEALLOCATE(svals, svdU)

  WRITE (*,'(/1x,a/)') '------- END -------------'

END PROGRAM generate_covar

